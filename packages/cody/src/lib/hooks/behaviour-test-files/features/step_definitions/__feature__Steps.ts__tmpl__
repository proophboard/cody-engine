import { before, binding, given, then, when } from "cucumber-tsflow";
import {<%= whenEvent.propertyName %>} from "@app/shared/commands/<%= serviceNames.fileName %>/<%= whenEvent.fileName %>";
import { Event } from "@event-engine/messaging/event";
import { getConfiguredMessageBox } from "@server/infrastructure/configuredMessageBox";
import { getConfiguredEventStore, PUBLIC_STREAM, WRITE_MODEL_STREAM } from "@server/infrastructure/configuredEventStore";
import {<%= givenEvent.propertyName %>} from "@app/shared/events/<%= serviceNames.fileName %>/<%= aggregate %>/<%= givenEvent.fileName %>";
import {<%= thenEvent.propertyName %>} from "@app/shared/events/<%= serviceNames.fileName %>/<%= aggregate %>/<%= thenEvent.fileName %>";
import expect from "expect";
import { setMessageMetadata } from "@event-engine/messaging/message";
import { AggregateMeta } from "@event-engine/infrastructure/AggregateRepository";

@binding()
// eslint-disable-next-line @typescript-eslint/no-unused-vars
class <%= feature %>Steps {
  private messageBox = getConfiguredMessageBox();
  private eventStore = getConfiguredEventStore();
  private events: Event[] = [];

  @before()
  public setup(): void {
    const listener = (streamName: string, events: Event[]) => {
      this.events.push(...events);
    };

    this.eventStore.createStream(WRITE_MODEL_STREAM);
    this.eventStore.createStream(PUBLIC_STREAM);
    this.eventStore.attachAppendToListener(listener);
  }

  @given('<%= given %>')
  public async given<%= givenEvent.className %>(): Promise<void> {
    const payload = {
      <%- givenPayload %>
    };

    let event = <%= givenEvent.propertyName %>(payload);

    event = setMessageMetadata(event, AggregateMeta.ID, '<%= expectedIdentifier %>');
    event = setMessageMetadata(event, AggregateMeta.TYPE, '<%= givenAggregateMetaType %>');
    event = setMessageMetadata(event, AggregateMeta.VERSION, 1);

    await this.eventStore.appendTo(WRITE_MODEL_STREAM, [event]);
    await this.messageBox.dispatch(event.name, event.payload, event.meta);
  }

  @when('<%= when %>')
  public async when<%= whenEvent.className %>(): Promise<void> {
    const payload = {
      <%- whenPayload %>
    };

    const command = <%= whenEvent.propertyName %>(payload);

    await this.messageBox.dispatch(command.name, command.payload, command.meta);
  }

  @then('<%= then %>')
  public async then<%= thenEvent.className %>(): Promise<void> {
    const identifier = '<%= expectedIdentifier %>';
    const expectedPayload = {
      <%- thenPayload %>
    };
    const expectedEvent = <%= thenEvent.propertyName %>(expectedPayload);

    const newestEventToCompare = this.events.
    filter((event: Event) => {
      return event.name === expectedEvent.name && event.meta.aggregateId === identifier;
    }).sort((event1, event2) => {
      return event2.createdAt.getTime() - event1.createdAt.getTime();
    }).pop();

    expect(newestEventToCompare).toBeDefined();
    expect(newestEventToCompare?.payload).toEqual(expectedPayload);
  }
}
